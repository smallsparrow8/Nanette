"""
Advanced Vulnerability Scanner for Smart Contracts
Detects common and critical security vulnerabilities
"""
import re
from typing import List, Dict, Any, Set


class VulnerabilityScanner:
    """Advanced vulnerability scanner for smart contracts"""

    def __init__(self):
        self.vulnerabilities = []

    def scan(self, source_code: str, abi: str = None) -> List[Dict[str, Any]]:
        """
        Perform comprehensive vulnerability scan

        Args:
            source_code: Contract source code
            abi: Contract ABI (optional)

        Returns:
            List of detected vulnerabilities
        """
        self.vulnerabilities = []

        if not source_code:
            return self.vulnerabilities

        # Run all vulnerability checks
        self._check_reentrancy(source_code)
        self._check_access_control(source_code)
        self._check_integer_issues(source_code)
        self._check_unchecked_calls(source_code)
        self._check_delegatecall(source_code)
        self._check_tx_origin(source_code)
        self._check_timestamp_dependency(source_code)
        self._check_dos_vulnerabilities(source_code)
        self._check_front_running(source_code)
        self._check_honeypot_patterns(source_code)

        return self.vulnerabilities

    def _add_vulnerability(self, vuln_type: str, severity: str, description: str,
                          recommendation: str = "", line: int = None):
        """Add a vulnerability to the list"""
        self.vulnerabilities.append({
            'type': vuln_type,
            'severity': severity,  # critical, high, medium, low
            'description': description,
            'recommendation': recommendation,
            'line': line
        })

    def _check_reentrancy(self, source_code: str):
        """Check for reentrancy vulnerabilities"""
        # Look for external calls before state changes
        functions = re.finditer(r'function\s+(\w+).*?\{(.*?)\}', source_code, re.DOTALL)

        for func in functions:
            func_body = func.group(2)

            # Find external calls
            external_calls = list(re.finditer(r'\.call\{value:|\.call\(|\.transfer\(|\.send\(', func_body))

            # Find state changes
            state_changes = list(re.finditer(r'(\w+)\s*=\s*|(\w+)\s*\+=|(\w+)\s*-=', func_body))

            # Check if external call comes before state change
            if external_calls and state_changes:
                for call in external_calls:
                    for change in state_changes:
                        if call.start() < change.start():
                            self._add_vulnerability(
                                'reentrancy',
                                'critical',
                                f'Potential reentrancy in function {func.group(1)}: External call before state change',
                                'Follow the Checks-Effects-Interactions pattern: Update state before making external calls'
                            )
                            break

    def _check_access_control(self, source_code: str):
        """Check for missing or weak access control"""
        # Critical functions that should have access control
        critical_functions = [
            'mint', 'burn', 'pause', 'unpause', 'setOwner', 'transferOwnership',
            'withdraw', 'setFee', 'setTax', 'blacklist', 'whitelist'
        ]

        for func_name in critical_functions:
            # Find function definitions
            pattern = rf'function\s+{func_name}\s*\([^)]*\)[^{{]*\{{([^}}]*)\}}'
            matches = re.finditer(pattern, source_code, re.IGNORECASE | re.DOTALL)

            for match in matches:
                func_body = match.group(1)

                # Check for access control modifiers
                if not any(modifier in source_code[:match.start()] for modifier in
                          ['onlyOwner', 'onlyRole', 'onlyAdmin', 'require(msg.sender ==', 'require(owner ==']):
                    self._add_vulnerability(
                        'missing_access_control',
                        'critical',
                        f'Function {func_name}() may lack proper access control',
                        'Add appropriate access control modifiers (e.g., onlyOwner, onlyRole)'
                    )

    def _check_integer_issues(self, source_code: str):
        """Check for integer overflow/underflow issues"""
        # Check Solidity version
        version_match = re.search(r'pragma\s+solidity\s+\^?(\d+)\.(\d+)\.', source_code)

        if version_match:
            major = int(version_match.group(1))
            minor = int(version_match.group(2))

            # Solidity < 0.8.0 doesn't have automatic overflow checks
            if major == 0 and minor < 8:
                # Check for arithmetic operations without SafeMath
                has_safemath = 'SafeMath' in source_code or 'using SafeMath' in source_code

                if not has_safemath:
                    # Look for arithmetic operations
                    if re.search(r'\+\s*\w+|\-\s*\w+|\*\s*\w+', source_code):
                        self._add_vulnerability(
                            'integer_overflow',
                            'high',
                            'Contract uses Solidity < 0.8.0 without SafeMath - vulnerable to integer overflow/underflow',
                            'Upgrade to Solidity ^0.8.0 or use SafeMath library'
                        )

    def _check_unchecked_calls(self, source_code: str):
        """Check for unchecked external calls"""
        # Look for .call(), .send(), .delegatecall() without checking return value
        patterns = [
            (r'\.call\([^;]*\);(?!\s*require)', 'call'),
            (r'\.send\([^;]*\);(?!\s*require)', 'send'),
            (r'\.delegatecall\([^;]*\);(?!\s*require)', 'delegatecall')
        ]

        for pattern, call_type in patterns:
            matches = re.finditer(pattern, source_code)
            for match in matches:
                self._add_vulnerability(
                    f'unchecked_{call_type}',
                    'high',
                    f'Unchecked {call_type}(): Return value not verified',
                    f'Always check the return value of {call_type}() calls'
                )

    def _check_delegatecall(self, source_code: str):
        """Check for dangerous delegatecall usage"""
        if '.delegatecall(' in source_code:
            self._add_vulnerability(
                'delegatecall_danger',
                'high',
                'Contract uses delegatecall which can be dangerous if called with untrusted address',
                'Ensure delegatecall is only used with trusted, immutable addresses'
            )

    def _check_tx_origin(self, source_code: str):
        """Check for tx.origin usage for authentication"""
        matches = re.finditer(r'require\s*\(\s*tx\.origin\s*==', source_code)
        for match in matches:
            self._add_vulnerability(
                'tx_origin_auth',
                'high',
                'Using tx.origin for authentication is vulnerable to phishing attacks',
                'Use msg.sender instead of tx.origin for authentication'
            )

    def _check_timestamp_dependency(self, source_code: str):
        """Check for block.timestamp dependency"""
        if 'block.timestamp' in source_code or 'now' in source_code:
            # Check if it's used in critical logic
            if re.search(r'(require|if)\s*\([^)]*block\.timestamp', source_code) or \
               re.search(r'(require|if)\s*\([^)]*\bnow\b', source_code):
                self._add_vulnerability(
                    'timestamp_dependency',
                    'medium',
                    'Contract relies on block.timestamp which can be manipulated by miners',
                    'Avoid using block.timestamp for critical logic; use block.number if possible'
                )

    def _check_dos_vulnerabilities(self, source_code: str):
        """Check for potential DoS vulnerabilities"""
        # Unbounded loops
        loop_patterns = [
            r'for\s*\([^)]*\.length[^)]*\)',
            r'while\s*\([^)]*\.length[^)]*\)'
        ]

        for pattern in loop_patterns:
            matches = re.finditer(pattern, source_code)
            for match in matches:
                self._add_vulnerability(
                    'unbounded_loop',
                    'medium',
                    'Potential DoS: Loop iterating over unbounded array',
                    'Limit array sizes or use pagination patterns'
                )

    def _check_front_running(self, source_code: str):
        """Check for potential front-running vulnerabilities"""
        # Functions that might be vulnerable to front-running
        if 'function buy' in source_code or 'function sell' in source_code:
            if 'slippage' not in source_code.lower():
                self._add_vulnerability(
                    'front_running',
                    'medium',
                    'Buy/sell functions may be vulnerable to front-running without slippage protection',
                    'Implement slippage protection and/or use commit-reveal schemes'
                )

    def _check_honeypot_patterns(self, source_code: str):
        """Check for common honeypot patterns"""
        honeypot_patterns = []

        # Hidden ownership
        if re.search(r'address\s+private\s+\w*owner', source_code, re.IGNORECASE):
            honeypot_patterns.append('Private owner variable - may hide ownership')

        # Transfer restrictions
        if 'onlyOwner' in source_code and 'transfer' in source_code:
            if re.search(r'require\s*\(\s*msg\.sender\s*==\s*owner', source_code):
                honeypot_patterns.append('Transfer may be restricted to owner only')

        # Blacklist mechanism
        if 'blacklist' in source_code.lower() or 'isBlacklisted' in source_code:
            honeypot_patterns.append('Blacklist mechanism present - users can be blocked from selling')

        # Hidden mint function
        if re.search(r'function\s+\w*[^m][^i][^n][^t]\w*.*mint', source_code, re.IGNORECASE):
            honeypot_patterns.append('Possible hidden mint function with obfuscated name')

        # Modifiable fees
        if 'setFee' in source_code or 'setTax' in source_code:
            honeypot_patterns.append('Fees/taxes can be modified by owner')

        # Maximum transaction amount that can be changed
        if 'setMaxTx' in source_code or 'setMaxTransaction' in source_code:
            honeypot_patterns.append('Maximum transaction limit can be modified')

        for pattern in honeypot_patterns:
            self._add_vulnerability(
                'honeypot_pattern',
                'high',
                f'Potential honeypot pattern detected: {pattern}',
                'Review contract carefully for malicious intent'
            )

    def get_critical_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Get only critical severity vulnerabilities"""
        return [v for v in self.vulnerabilities if v['severity'] == 'critical']

    def get_vulnerability_count_by_severity(self) -> Dict[str, int]:
        """Get count of vulnerabilities by severity"""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        for vuln in self.vulnerabilities:
            counts[vuln['severity']] += 1
        return counts
